
do -- RUN ME FIRST FOR A BIT TO FILL THE RESAMPLING BUFFER UP!
  let rec = make' VF rec_p     -- let's make a rec param so we can
      rec_p = F "rec" Nothing  -- trigger our resampling system
  cps 1
  d2 $ s "bd" # gain 0 # rec 1  -- this plays a sample at 0 gain because we don't want to hear it, but we gotta play something to send the rec message to the resampler
  d1 $ stack [loopAt 1 $ s "ravemono", loopAt 1 $ s "rec" |*| gain 1] -- let's feed the resampling buffer some audio

----------------------------------------------------------------------
----------------------------------------------------------------------

do -- RUN ME NEXT TO MASH IT UP!
  let rec = make' VF rec_p     -- let's make a rec param so we can
      rec_p = F "rec" Nothing  -- trigger our resampling system
  let recycle = s "bd" # gain 0 # rec 1 -- this plays a sample at 0 gain because we don't want to hear it, but we gotta play something to send the rec message to the resampler
  let ss = inside 1 (foldEvery [2,3,4] (((1/8) <~).(|*| speed "<-2 0.5 4 -0.25>"))) $       -- mash it up
        loopAt 1 $ chop 4 $ s "rec*4" |*| gain 1.4 # release 0.8 # coarse "<2 4 1 6 16>*2"  -- plz&thx
  let justLoop = loopAt 1 $ s "rec" |*| gain 1.37 -- just keep looping without mashing up
  d1 $ ss -- put justLoop here instead if you just want to repeat what's in the resampling buffer (loop without mashing it up)
  d2 $ recycle -- run the thing that keeps the resampling going

----------------------------------------------------------------------
----------------------------------------------------------------------

hush
